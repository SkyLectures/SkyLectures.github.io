---
layout: page
title:  "OpenCV 기초"
date:   2025-07-29 10:00:00 +0900
permalink: /materials/S03-02-03-02_01-OpenCv
categories: materials
---
* toc
{:toc .large-only .toc-sticky:true}


<div class="insert-image" style="text-align: center;">
    <img style="width: 400px;" src="/assets/img/PagePreparing.png">
</div>




스카이님, 안녕하세요! 모빌리티 AI 강의에 활용하실 OpenCV 기초 강의 자료를 상세하게 정리해 드리겠습니다. 비전공자 학생분들이 쉽고 재미있게 이해하고 실습할 수 있도록 핵심 개념과 코드를 함께 제시하겠습니다.

---

# **OpenCV 기초 강의 자료: 자율주행 영상 처리를 위한 첫걸음**

## **[차시 목표]**

*   OpenCV 라이브러리의 역할과 자율주행에서의 중요성을 이해한다.
*   디지털 이미지의 구조(픽셀, 해상도, 색상 공간)를 설명할 수 있다.
*   Raspberry Pi 환경에서 OpenCV를 설치하고 기본 사용법을 익힌다.
*   OpenCV를 이용하여 이미지 및 비디오를 불러오고, 표시하고, 저장하는 기본 작업을 수행한다.
*   이미지 내 픽셀 접근 및 색상 공간 변환 등 기초적인 영상 처리 기술을 적용한다.

---

## **1. OpenCV란 무엇이며, 왜 중요한가요?**

### 1.1. OpenCV 소개
*   **OpenCV (Open Source Computer Vision Library)**는 컴퓨터 비전 및 머신러닝 애플리케이션 개발을 위한 오픈소스 라이브러리입니다.
*   다양한 프로그래밍 언어(C++, Python, Java 등)를 지원하며, 실시간 영상 처리에 매우 강력한 기능을 제공합니다.
*   **컴퓨터 비전(Computer Vision)**: 컴퓨터가 사람의 눈처럼 이미지나 비디오를 '보고' 이해하도록 만드는 인공지능 분야입니다.

### 1.2. 자율주행 및 모빌리티 AI에서의 OpenCV
*   **핵심 역할**: 자율주행차의 '눈'인 카메라 센서에서 들어오는 영상 데이터를 처리하고 분석하는 데 필수적으로 사용됩니다.
*   **주요 활용 예시**:
    *   **객체 인식**: 도로 위의 차량, 보행자, 자전거 등을 탐지하고 분류합니다.
    *   **차선 인식**: 차량이 주행해야 할 차선을 식별하고 추적합니다.
    *   **신호등 및 표지판 인식**: 교통 신호와 도로 표지판의 종류를 판독하여 차량의 행동을 결정합니다.
    *   **거리 측정**: 스테레오 비전이나 단안 카메라 기반의 기술로 객체까지의 거리를 추정합니다.
    *   **환경 인지**: 악천후(비, 눈, 안개) 환경에서 영상 품질을 개선하거나, 주변 환경 정보를 추출합니다.

---

## **2. 디지털 이미지의 기본 구조 복습**

OpenCV를 본격적으로 다루기 전에, 디지털 이미지가 어떻게 구성되어 있는지 다시 한번 살펴볼까요?

### 2.1. 픽셀(Pixel)
*   디지털 이미지의 가장 작은 점 단위로, 각각 고유한 색상 정보를 가집니다.
*   모든 이미지는 이 픽셀들의 촘촘한 배열로 이루어져 있습니다.
*   **좌표**: OpenCV에서는 주로 `(x, y)` 형태로 픽셀 위치를 나타내며, `(0, 0)`은 이미지의 **좌측 상단**입니다.

### 2.2. 해상도(Resolution)
*   이미지의 가로 및 세로 픽셀 수를 의미합니다 (예: 1920x1080).
*   해상도가 높을수록 이미지가 더 선명하고 상세한 정보를 담을 수 있지만, 처리 시간과 메모리 사용량이 증가합니다.

### 2.3. 색상 공간(Color Space)
*   **그레이스케일(Grayscale)**:
    *   흑백 이미지로, 각 픽셀은 밝기(명암) 값만 가집니다.
    *   일반적으로 0(검은색)부터 255(흰색)까지 256단계로 밝기를 표현합니다.
    *   색상 정보가 중요하지 않은 차선 인식이나 에지(가장자리) 검출에 많이 사용됩니다.
*   **RGB / BGR**:
    *   Red, Green, Blue 세 가지 기본 색상을 조합하여 다양한 색상을 표현합니다.
    *   각 픽셀은 R, G, B 채널에 대한 밝기 값을 가집니다(각 0~255).
    *   **주의**: OpenCV에서는 **BGR 순서(파랑, 초록, 빨강)**로 채널이 저장됩니다.
*   **HSV**:
    *   Hue(색상), Saturation(채도), Value(명도)로 색상을 표현합니다.
    *   특정 색상을 추출하거나 조명 변화에 강인한 영상 처리에 유용합니다 (예: 특정 색상의 교통 표지판 인식).

---

## **3. OpenCV 개발 환경 설정 (Raspberry Pi)**

Raspberry Pi에서 OpenCV를 설치하는 방법은 다음과 같습니다. 인터넷 연결이 필요합니다.

```bash
# 1. 시스템 업데이트
sudo apt update
sudo apt upgrade

# 2. OpenCV 설치에 필요한 패키지 설치
sudo apt install build-essential cmake pkg-config
sudo apt install libjpeg-dev libtiff-dev libpng-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev
sudo apt install libxvidcore-dev libx264-dev libgtk-3-dev libatlas-base-dev gfortran
sudo apt install python3-dev python3-pip

# 3. OpenCV 파이썬 라이브러리 설치
# (시간이 꽤 소요될 수 있습니다. 인내심을 가지고 기다려주세요!)
pip3 install opencv-python numpy
```
*   설치 후 Python에서 `import cv2`가 성공하면 됩니다.

---

## **4. OpenCV를 이용한 이미지 기본 작업**

### 4.1. 이미지 불러오기 (`cv2.imread()`)
*   지정된 경로의 이미지를 NumPy 배열 형태로 메모리에 로드합니다.
*   **경로**: 이미지 파일의 정확한 경로를 지정해야 합니다. (예: `images/my_car.jpg`)
*   **Flags**: `cv2.IMREAD_COLOR`(기본값, 컬러로 로드), `cv2.IMREAD_GRAYSCALE`(그레이스케일로 로드) 등.

```python
import cv2
import matplotlib.pyplot as plt # 이미지를 시각화하기 위해 임시로 사용

# 이미지를 불러옵니다. (OpenCV는 BGR 순서)
# (이미지 파일 경로를 여러분의 환경에 맞게 변경하세요!)
image_path = 'images/traffic_light.jpg' 
img_color = cv2.imread(image_path, cv2.IMREAD_COLOR)

# 이미지가 제대로 로드되었는지 확인
if img_color is None:
    print(f"오류: {image_path} 파일을 찾을 수 없거나 불러올 수 없습니다.")
else:
    print("이미지 불러오기 성공!")
    print(f"이미지 형태 (높이, 너비, 채널): {img_color.shape}") # 예: (480, 640, 3)
    print(f"이미지 데이터 타입: {img_color.dtype}") # 예: uint8

    # OpenCV는 BGR 순서로 읽으므로, Matplotlib으로 표시하려면 RGB로 변환해야 합니다.
    # (cv2.imshow() 사용 시에는 변환 불필요)
    img_rgb = cv2.cvtColor(img_color, cv2.COLOR_BGR2RGB)
    
    plt.imshow(img_rgb)
    plt.title("원본 컬러 이미지")
    plt.axis('off') # 축 정보 숨기기
    plt.show()
```
*   **참고**: Matplotlib은 Python에서 이미지와 그래프를 쉽게 보여주는 라이브러리입니다. 강의 초반에는 `plt.imshow()`를 통해 이미지를 시각적으로 확인하는 것이 유용합니다. 실제 자율주행에서는 `cv2.imshow()`를 주로 사용합니다.

### 4.2. 이미지 표시하기 (`cv2.imshow()`)
*   새로운 창에 이미지를 표시합니다.
*   **`cv2.waitKey()`**: 키 입력을 기다리는 함수입니다. 0을 인자로 주면 무한정 대기하며, 특정 시간(밀리초)을 주면 해당 시간 동안 기다립니다.
*   **`cv2.destroyAllWindows()`**: 생성된 모든 OpenCV 창을 닫습니다.

```python
# (위의 이미지 불러오기 코드와 이어서 실행)

if img_color is not None:
    cv2.imshow('Traffic Light Image', img_color) # 'Traffic Light Image'는 창 이름
    
    cv2.waitKey(0) # 키 입력이 있을 때까지 무한정 대기
    cv2.destroyAllWindows() # 모든 창 닫기
```

### 4.3. 이미지 저장하기 (`cv2.imwrite()`)
*   처리된 이미지를 파일로 저장합니다.
*   **확장자**: 이미지 형식(png, jpg, bmp 등)은 확장자에 따라 자동으로 결정됩니다.

```python
# 그레이스케일 이미지로 변환 후 저장하는 예시
if img_color is not None:
    img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)
    cv2.imwrite('images/traffic_light_gray.jpg', img_gray)
    print("그레이스케일 이미지 저장 완료!")
```

### 4.4. 픽셀 접근 및 수정
*   NumPy 배열의 인덱싱을 사용하여 특정 픽셀의 값에 접근하거나 수정할 수 있습니다.
*   컬러 이미지의 경우 `[y좌표, x좌표, 채널]` 형태로 접근합니다. (채널 순서: BGR)

```python
if img_color is not None:
    # (높이-1, 너비-1) 픽셀의 BGR 값 확인 (우측 하단)
    # y좌표: img_color.shape[0] - 1, x좌표: img_color.shape[1] - 1
    bottom_right_pixel = img_color[img_color.shape[0] - 1, img_color.shape[1] - 1]
    print(f"우측 하단 픽셀 (BGR): {bottom_right_pixel}") # 예: [120, 100, 80]

    # 특정 픽셀 (예: 이미지 중앙)의 색상을 빨간색으로 변경
    center_y, center_x = img_color.shape[0] // 2, img_color.shape[1] // 2
    img_color[center_y, center_x] = [0, 0, 255] # B=0, G=0, R=255 (순수한 빨간색)

    # 수정된 이미지를 확인
    cv2.imshow('Modified Image', img_color)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

### 4.5. 이미지 속성 확인
*   `.shape`: 이미지의 형태 (높이, 너비, 채널 수)
*   `.size`: 전체 픽셀 수 (높이 * 너비 * 채널 수)
*   `.dtype`: 이미지 픽셀 데이터 타입 (일반적으로 `uint8`)

```python
if img_color is not None:
    print(f"이미지 형태 (높이, 너비, 채널): {img_color.shape}")
    print(f"전체 픽셀 수: {img_color.size}")
    print(f"데이터 타입: {img_color.dtype}")
```

### 4.6. 색상 공간 변환 (`cv2.cvtColor()`)
*   이미지를 다른 색상 공간으로 변환합니다 (예: BGR -> 그레이스케일, BGR -> HSV).
*   자율주행에서 특정 색상을 강조하거나, 색상 정보가 불필요한 연산에서 속도 향상을 위해 사용됩니다.

```python
if img_color is not None:
    # BGR을 그레이스케일로 변환
    img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)
    cv2.imshow('Grayscale Image', img_gray)
    print(f"그레이스케일 이미지 형태: {img_gray.shape}") # 예: (480, 640)

    # BGR을 HSV로 변환
    img_hsv = cv2.cvtColor(img_color, cv2.COLOR_BGR2HSV)
    cv2.imshow('HSV Image', img_hsv)
    print(f"HSV 이미지 형태: {img_hsv.shape}") # 예: (480, 640, 3)

    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

### 4.7. 이미지 크기 조정 (`cv2.resize()`)
*   이미지의 가로/세로 크기를 변경합니다. 딥러닝 모델의 입력 크기를 맞추거나, 처리 속도 향상을 위해 주로 사용됩니다.
*   `interpolation` (보간법) 파라미터는 이미지를 늘리거나 줄일 때 픽셀 값을 어떻게 채울지 결정합니다.

```python
if img_color is not None:
    # 이미지 절반 크기로 줄이기 (가로/세로 0.5배)
    img_resized_half = cv2.resize(img_color, (0, 0), fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)
    cv2.imshow('Resized Half', img_resized_half)
    print(f"절반 크기 이미지 형태: {img_resized_half.shape}")

    # 이미지 두 배 크기로 늘리기 (가로/세로 2배)
    img_resized_double = cv2.resize(img_color, (0, 0), fx=2, fy=2, interpolation=cv2.INTER_CUBIC)
    cv2.imshow('Resized Double', img_resized_double)
    print(f"두 배 크기 이미지 형태: {img_resized_double.shape}")

    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

---

## **5. OpenCV를 이용한 기본 영상 처리**

### 5.1. 이미지 이진화 (Thresholding, `cv2.threshold()`)
*   이미지의 픽셀 값을 특정 기준(임계값)에 따라 흑 또는 백으로 만드는 과정입니다.
*   배경과 객체를 분리하거나, 특정 특징을 강조할 때 사용됩니다 (예: 어두운 도로에서 밝은 차선 추출).

```python
if img_color is not None:
    img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

    # 전역 이진화: 127을 임계값으로 사용
    # 127보다 크면 255(흰색), 작거나 같으면 0(검은색)
    ret, img_binary = cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)
    cv2.imshow('Binary Image', img_binary)

    # 이진화 결과도 종종 유용한 정보를 포함합니다.
    print(f"이진화 반환 값 (ret): {ret}") 

    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

### 5.2. 이미지 블러링 (Blurring, 노이즈 제거, `cv2.GaussianBlur()`)
*   이미지를 부드럽게 만들어 노이즈를 줄이는 필터링 작업입니다.
*   미세한 노이즈로 인한 오작동을 방지하고, 에지 검출 등의 전처리 단계로 자주 사용됩니다.

```python
if img_color is not None:
    # 가우시안 블러 (5x5 커널 크기)
    img_blur = cv2.GaussianBlur(img_color, (5, 5), 0)
    cv2.imshow('Original', img_color)
    cv2.imshow('Blurred', img_blur)

    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

### 5.3. 에지(Edge) 검출 (`cv2.Canny()`)
*   이미지에서 밝기 변화가 급격한 부분을 찾아 선(경계선)으로 표시합니다.
*   객체의 윤곽선을 추출하여 자율주행 시 차량, 도로 경계 등을 파악하는 데 활용됩니다.
*   Canny 에지 검출은 노이즈 억제, 에지 방향 찾기, 이력 임계값 적용 등 여러 단계로 구성되어 있어 매우 강력합니다.

```python
if img_color is not None:
    img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)
    img_blur = cv2.GaussianBlur(img_gray, (5, 5), 0) # 노이즈 제거 후 에지 검출

    # Canny 에지 검출 (하위 임계값=50, 상위 임계값=150)
    edges = cv2.Canny(img_blur, 50, 150)
    cv2.imshow('Original', img_color)
    cv2.imshow('Edges', edges)

    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

### 5.4. ROI (Region of Interest) 추출
*   이미지의 특정 관심 영역만 선택하여 처리합니다. 불필요한 영역을 제외하고 처리함으로써 연산 효율을 높입니다.
*   자율주행 시에는 주로 도로 영역만 선택하여 차선이나 장애물 인식을 수행하는 데 사용됩니다.

```python
if img_color is not None:
    # 이미지 하단 절반을 ROI로 설정 (도로 영역이라고 가정)
    height, width = img_color.shape[:2]
    roi_start_y = int(height * 0.5) # 이미지 높이의 절반부터 시작
    roi_end_y = height
    roi_start_x = 0
    roi_end_x = width

    roi = img_color[roi_start_y:roi_end_y, roi_start_x:roi_end_x]
    
    cv2.imshow('Original Image', img_color)
    cv2.imshow('Region of Interest (ROI)', roi)

    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

---

## **6. Raspberry Pi 카메라를 이용한 비디오 처리 (실시간)**

Raspberry Pi와 카메라 모듈을 연결하여 실시간으로 영상을 캡처하고 처리하는 방법을 배워보겠습니다.

### 6.1. 비디오 캡처 객체 생성 (`cv2.VideoCapture()`)
*   카메라 인덱스 (0, 1 등)나 비디오 파일 경로를 인자로 전달하여 비디오 스트림을 엽니다.
*   Raspberry Pi 카메라 모듈의 경우 `0` 또는 `-1`을 사용하거나, `gst-launch` 같은 파이프라인을 사용할 수도 있습니다 (여기서는 간단한 `0`을 예시).

### 6.2. 프레임 읽기 (`read()`)
*   비디오 스트림에서 한 프레임(이미지)씩 읽어옵니다.

### 6.3. 무한 루프와 종료 조건
*   비디오 처리는 일반적으로 무한 루프 내에서 각 프레임을 처리하고, 특정 키(예: 'q' 키) 입력 시 루프를 종료하도록 구현합니다.

```python
# 카메라 객체 생성 (0번 카메라, 라즈베리파이 카메라 모듈이 연결되어 있다고 가정)
cap = cv2.VideoCapture(0)

# 카메라가 제대로 열렸는지 확인
if not cap.isOpened():
    print("오류: 카메라를 열 수 없습니다.")
else:
    print("카메라 연결 성공!")
    while True:
        ret, frame = cap.read() # 프레임 읽기 (ret: 성공 여부, frame: 이미지 데이터)

        if not ret: # 프레임을 제대로 읽지 못하면 종료
            print("프레임을 받지 못했습니다. 종료합니다.")
            break

        # 예시: 캡처된 프레임을 그레이스케일로 변환하여 표시
        gray_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        cv2.imshow('Live Camera Feed (Original)', frame)
        cv2.imshow('Live Camera Feed (Grayscale)', gray_frame)

        # 'q' 키를 누르면 종료
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # 사용이 끝난 카메라 객체 해제
    cap.release()
    cv2.destroyAllWindows()
    print("비디오 스트리밍 종료.")
```

---

## **7. 실습 과제 및 응용 아이디어**

1.  **나만의 필터 만들기**: Raspberry Pi 카메라에서 실시간으로 들어오는 영상에 블러링, 에지 검출 등 2가지 이상의 영상 처리 기법을 연속적으로 적용하여 표시해 보세요.
2.  **색상 기반 객체 강조**: 특정 색상(예: 빨간색 공, 파란색 표지판)만 영상에서 검출하여 마스킹하거나 테두리를 그려 강조하는 코드를 작성해 보세요 (HSV 색상 공간 변환 활용).
3.  **ROI 기반 차선 영역 분리**: 실시간 영상에서 도로의 차선이 주로 위치할 것으로 예상되는 하단 삼각형 영역을 ROI로 설정하고, 해당 영역에만 에지 검출을 적용하여 표시해 보세요.
4.  **카메라 영상 저장**: 'q' 키로 종료하기 전, 비디오 스트림의 마지막 100프레임을 비디오 파일로 저장하는 기능을 추가해 보세요.

---

스카이님, 이 자료가 비전공자 학생분들을 위한 OpenCV 기초 강의에 큰 도움이 되기를 바랍니다! 이론 설명과 함께 바로바로 실습해볼 수 있도록 작은 코드 예제들을 많이 포함했습니다. 학생들이 직접 코드를 실행하고 결과를 눈으로 확인하며 재미있게 배울 수 있도록 지도해 주세요. 응원하겠습니다!