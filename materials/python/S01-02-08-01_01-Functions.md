---
layout: page
title:  "파이썬 중급: 함수"
date:   2025-03-01 10:00:00 +0900
permalink: /materials/S01-02-08-01_01-Functions
categories: materials
---
* toc
{:toc .large-only .toc-sticky:true}

# **함수(Function)**

## **1. 함수의 정의및 호출**

- 함수
    - 반복되는 로직을 하나의 기능으로 묶어 재사용할 수 있도록 구조화해서 모듈 내의 하나로 처리할 수 있는 기능으로 정의하여 활용하는 방법, 또는 그 단위
- 함수의 구현 방식
    - 정의문을 통해 정의한 후에 사용할 수 있는 방식
    - 정의한 후에 바로 실행이 가능한 방식: 람다 표현식(람다 함수, 익명 함수)

### 1.1 함수의 정의 및 호출

- 함수를 정의하는 이유
    - 함수를 먼저 정의해야 프로그램을 로딩할 때 함수가 실행될 수 있는 구조를 파이썬 내부적으로 생성할 수 있음


def func(par1, par2) :
    """ 이 함수는 아무런 행동을 하지 않음 """
    pass

print(func)
print(type(func))
print(func.__doc__)


help(func)

- 함수의 호출
    - 함수가 정의되면 내부적으로 로딩 되면서 function class의 인스턴스로 만들어짐
    - 함수의 매개변수(파라미터)는 함수의 지역변수로 사용됨


def func(x,y) :
    """ 이 함수는 x+y이 결과를 출력"""

    return x+y

print(func(10,10))

print(func(10))

- 함수 정의와 호출 순서
    - 모듈 내에 함수가 정의된 경우
        - 모듈이 로딩될 때 함수도 로딩됨
        - 함수의 정의문에서 작성한 함수 이름을 Key로, 함수의 인스턴스가 Value로 들어감
        - 함수의 조회
            - globals(): 모듈 내의 전역 네임스페이스를 조회하는 내장함수
            - 파이썬의 네임 스페이스는 딕셔너리 자료형으로 관리됨
            - 함수의 이름을 Key로 하여 딕셔너리 자료형에서 조회
            - globals() 함수의 결과도 딕셔너리 자료형이므로 함수의 이름을 문자열로 하여 조회
            - 인스턴스의 레퍼런스(참조)가 동일한지 확인하려면 is 키워드로 비교함(동일하면 True)
    - 함수의 호출
        - 함수의 이름으로 호출함
        - 모듈의 전역 네임스페이스에 이 함수의 이름이 있는지 확인
            - 함수의 이름이 존재한다면 함수의 인스턴스를 실행해서 결과를 반환함
            - 함수의 이름이 존재하지 않는다면 이름이 정의되지 않았다는 예외를 발생시킴

addx(7,3)

def addx(x,y) :
    return x+y

def addx(x,y) :
    print(" addx call ")
    return x+y

print(globals()["addx"])
print(addx)
print(globals()["addx"] is addx)


print(addx(50,60))

addx = globals()["addx"]

print(addx(20,30))

- 함수 파라미터 자료형 제한하기
    - 제너릭(Generic) 함수: 함수의 매개변수를 지정하면 어떠한 자료형이라도 인자로 전달하여 호출할 수 있는 함수의 정의/처리 방식
    - 파이썬의 함수는 기본적으로 제너릭 함수
    - 따라서 매개변수에 전달하는 인자를 특정 자료형으로만 제어할 필요가 있을 경우에는 함수 내부에서 별도의 로직으로 처리해야 함


def generic_add(x, y):
    return x + y

print(generic_add(5, 5))
print(generic_add("Hello", "World"))

def add(x,y) :
    if not isinstance(x,int) :
        raise ValueError(" x is not integer ")
    if not isinstance(y,int) :
        raise ValueError(" y is not integer ")

    return x+y


add(11.1, 10)

add(10,11.1)

add(10,10)

### **1.2 함수 호출 연산자 이해하기**

- 함수를 호출할 때 괄호를 사용하고 괄호 속에 인자를 넣어 전달하면 함수가 해당 인자를 사용하여 실행됨
- 함수 호출 연산자인 괄호는 어떻게 사용되는가?
    - 함수는 기본적으로 function 클래스의 인스턴스이므로 호출 연산자도 메서드를 이용해서 처리됨
    - 파이썬 내부적으로 함수 호출 연산자는 __ call __ 메서드를 실행하여 처리함

- 함수 호출 연산자
    - 내장함수 callable을 이용하여 함수가 호출이 가능한지 확인할 수 있음
    - 내장함수 callable은 객체 내의 스페셜 메서드인 __ call __의 존재 여부를 확인해서 있으면 True를 출력함
    - 함수의 이름에 점 연산자를 이용하여 메서드 __ call __을 출력하면 메서드의 레퍼런스를 확인할 수 있음
        - method-wrapper로 출력된 것은 이 메서드가 호출이 가능한 내부적인 메서드를 제공한다는 의미임


def mul(x,y) :
    return x*y

print(mul)

print(callable(mul))

print(mul(10,10))

print(mul.__call__)
print(mul.__call__(10,10))

- 함수 객체의 바인딩 규칙
    - 클래스는 모든 메서드를 관리함
    - 인스턴스
        - 클래스를 검색해 인스턴스 메서드에 인스턴스 인자를 전달하면 메서드를 실행
            - 인스턴스 메서드일 경우, 인스턴스 인자를 전달하고 이를 바인딩하여 메서드를 실행함
        - 함수도 클래스 function의 인스턴스이므로 실행할 때, __ call __ 메서드를 바인딩해서 처리함(처리 방식은 동일함)

- 함수 호출 바인딩 절차
    - 함수가 어떤 클래스의 인스턴스인지 확인하기 위하여 해당 인스턴스의 __ class __ 속성을 점 연산자로 확인하면 클래스 정보를 출력함
    - 함수가 인스턴스 이므로 __ call __ 메서드를 점 연산자로 확인하면 메서드 여부를 확인 가능


def sub(x,y) :
    return x-y

print(type(sub))
print(sub.__class__)

print(sub.__class__.__call__)
print(sub.__call__)

print(sub.__class__.__call__(sub,10,10))
print(sub.__call__(10,10))

### **1.3 함수 return문 처리**

- 함수의 반환 처리  
    - 함수는 기본적으로 반드시 return을 사용함
    - 결과를 반환한 필요가 없는 함수도 내부적으로 None을 반환함
    - 함수의 결과는 지역 네임스페이스를 통해 외부로 전달함
        - 지역 네임스페이스는 딕셔너리로 구성되므로 전달한 결과도 딕셔너리를 출력함

def str_prt(x) :
    print(x)

a = str_prt(" return 문이 없을 때 ")
print(a)

def str_rtn(x) :
    return x

a = str_rtn(" return 문이 있을 때 ")
print(a)

- 함수의 반환을 여러 개가 필요한 경우
    - 여러 개의 값을 반환하려면 여러 개의 원소를 하나로 구성하는 자료형에 묶어서 반환함
    - return a, b 처럼 ,로 구분하는 것은 기본적으로 튜플을 생성하는 방법임. 즉 튜플로 반환함


def func_tuple(x,y,z) :
    return x,y,z

a = func_tuple(10,20,30)
print(type(a), a)

def func_dict(x,y,z) :
    return locals()

a = func_dict(10,20,30)
print(type(a), a)

### **1.4 함수는 function 클래스의 인스턴스 객체**

- 파이썬은 모든 것을 객체로 관리
- 함수는 function 클래스의 인스턴스
- 함수가 만들어지면 기본 정보는 function 클래스의 속성에서 관리
- 실행에 필요한 정보는 code 클래스 내에서 관리

- 함수의 기본 속성을 확인해 보기
    - 함수를 정의할 때 매개변수에 자료형과 초기값을 할당함
    - 매개변수 할당 시 *에는 아무런 변수를 부여하지 않는 이유: 다음에 인자를 전달할 때에는 반드시 키워드 인자로 전달해야 함을 의미
    - 반환값에 필요한 자료형을 선언하기 위해 매개변수를 정의한 다음 -> 이후에 자료형을 정의: 반환값의 결과에 대한 자료형을 확정

import pprint

def div(x:int=100,*, y:int=100) -> float:
    return x/y

s = set(dir(div))
o = set(dir(object))

pprint.pprint(s-o)

print(div())

print(div.__name__)
print(div.__qualname__)
print(div.__annotations__)
print(div.__defaults__)
print(div.__kwdefaults__)

print(div.__module__)
print(div)
print(div.__globals__['div'])

- 함수에 대한 사용자 객체속성 추가
    - 함수도 하나의 인스턴스 객체이므로 인스턴스 내부의 네임스페이스가 존재함
    - 따라서 함수에도 함수의 인스턴스를 추가하거나 삭제가 가능함


def func_state(x,y) :
    func_state.count += 1
    return x+y

func_state.count = 0

print(func_state.__dict__)
print(func_state(10,10))
print(func_state(10,10))
print(func_state(10,10))
print(func_state.__dict__)

- 모듈 내의 함수에 대한 정보를 조회하기

def func_state(x,y) :
    func_state.count += 1
    return x+y

print(func_state.__module__)
func_state.count = 0
print(func_state.__globals__['func_state'](10,10))
print(func_state.__dict__)

## **2. 함수의 변수 네임스페이스와 스코프 처리**

- 스코프(Scope)
    - 지역과 전역 등에 대한 처리규칙
        - 함수 내 지역 네임스페이스에 없는 것을 상위 모듈의 전역 네임스페이스를 검색해서 처리하는 등
- 함수 정의 시 매개변수를 지정하면 함수 호출 시 변수와 값이 지역 네임스페이스에 할당됨
    - 함수 정의 시 매개변수에 초기값을 주는 경우
        - 이 초기값은 함수의 지역 네임스페이스에 만들어지지 않고 객체의 네임스페이스에서 별도의 속성에 들어감
        - 여러 번 함수가 호출되어도 단지 네임스페이스를 갱신하는 것이므로
            - 함수의 인스턴스 속성이 초기값 스페셜 속성을 변경하지 않음
        - 함수의 네임스페이스는 함수를 호출할 때마다 생성되므로 함수 실행이 종료되면 지역 네임스페이스는 사라짐
- 함수가 모듈과 전역 네임스페이스에 대한 정보를 가지고 다니는 이유
    - 함수가 항상 자신이 속한 모듈에서 처리되고
    - 전역 네임스페이스는 항상 자기가 속한 모듈을 사용하기 때문
    - 이렇게 해야 함수에 없는 것을 네임스페이스에서 찾아 호출하거나, 이곳에도 없으면 내장 네임스페이스를 검색하고, 거기에도 없으면 예외로 처리할 수 있음

### 2.1 함수 Namespace 및 Scope 규칙

- 파이썬 네임스페이스에는 전역(global), 지역(local), 그리고 제일 상위인 내장(builtins)이 있음
- 지역과 전역의 범위
    - 모든 네임스페이스는 딕셔너리가 기본이므로 항상 키와 값을 쌍으로 처리함
    - 함수와 모듈에 정의된 변수는 네임스페이스의 키로 들어감
        - 이 키를 검색하여 값을 가져오고
        - 그 값이 어떤 자료형으로 저장되었나에 따라서 처리하는 연산이 달라짐
    - 변수가 정의되면
        - 이 변수가 어느 영역의 네임스페이스에 저장되는지가 중요함
        - 그래야 변수의 참조에 대한 규칙에 따라 검색해서 발견되면 더 이상 상위로 가지 않고 그 값을 로직에서 처리할 수 있음
        - 변수의 참조 규칙은 Local > Global > Built-In 순서
            - 함수가 호출될 때 현재 위치부터 출발해서 네임스페이스를 처리함
            - 현재 위치에서 변수의 이름을 검색했는데 없으면 상위로 올라가고... 최상위까지 가도 없다면 예외 발생(스코프)
            - 함수의 전역 규약은 항상 자신이 속한 모듈(함수의 속성에 모듈과 전역 네임스페이스를 항상 가지고 있는 이유)
            - 파이썬 엔진에서 기본으로 제공하는 네임스페이스는 내장(Builtins)으로 변수 네임스페이스의 최상위가 됨



- 모듈은 전역, 함수는 지역으로 인식
    - 주피터노트북의 셀에서 %%writefile 파이썬 모듈명을 주고 그 밑으로 변수와 함수 등을 정의하면 하나의 모듈이 만들어짐

%%writefile glb_loc1.py

glb_var = 100

def add(x,y) :
    print(locals())
    print("globals ",add.__globals__["glb_var"])
    return x+y

print(add.__module__)
print(add.__globals__["add"])

import glb_loc1

print(glb_loc1.add(10,20))
print(globals()["glb_loc1"])

- 함수 별로 지역 네임스페이스 처리


def func_1(x,y) :
    print(locals())

def func_2(x,y) :
    print(locals())

func_1(100,100)
func_2(150,150)

### 2.2 함수 내부에서 전역 변수를 확정해서 처리

- 자동으로 전역 변수 접근


def func_1(x,y) :
    print(locals())
    print("func_1 z ",z)

def func_2(x,y) :
    print(locals())
    print("func_2 z ",z)

z = 9999
func_1(100,100)
func_2(150,150)


print(globals()["z"])
print(globals()["func_1"])
print(globals()["func_2"])

- global 키워드로 글로벌 변수 명기하기


glb_var = 8888

def add(y) :
    global glb_var
    x = glb_var + y
    return x

print(glb_var)
print(add(10))
print(glb_var)

glb_var = 8888

def add(y) :
    #global glb_var
    glb_var = glb_var + y
    return x

print(glb_var)
print(add(10))
print(glb_var)

glb_var = 8888

def add(y) :
    global glb_var
    glb_var = glb_var + y
    print(locals())
    return glb_var

print(glb_var)
print(add(10))
print(glb_var)

### 2.3 함수에서 객체 네임스페이스 접근하기

- 타 클래스의 속성 참조

import pprint

class A :
    name = "A"
    def __init__(self) :
        self.name = "A class instance "

def class_func() :
    return A.name

print(class_func())
pprint.pprint(A.__dict__)


class A :
    name = "A"
    def __init__(self) :
        self.name = "A class instance "


def instance_func(a) :
    return a.name

a = A()
print(instance_func(a))
print(a.__dict__)

## **3. 람다 함수(Lambda Function)**

- 람다함수(Lambda Function)
    - 런타임에 생성해서 사용할 수 있는 익명 함수    
    - 필요성
        - 상황에 따라 직접 정의해서 바로 사용하는 것이 필요할 때가 있음
        - 1회성으로 한 번 쓰고 버리는 용도로 많이 사용함
    - 사용 방식
        - 함수 정의문이 없으므로 lambda라는 키워드를 사용함
        - 하나의 라인에 정의할 수 있음
        - 콜론(:)을 경계로 앞에는 매개변수를 정의하고 뒤에는 표현식을 정의함
        - 표현식 대신 문장으로 표현하면 예외가 발생하므로 반환값을 처리하는 return문이 필요없고 표현식을 실행한 결과가 자동으로 반환됨
        - 함수를 정의문으로 정의한 것과 내부적으로 거의 동일하게 처리됨

### 3.1 람다 함수 정의하기

- 함수 정의문과 람다 함수의 변수 할당 비교


def add(x,y) :
    return x+y

print(add(10,10))

a = lambda x,y : x+y
print(a(10,10))

- 람다 함수도 function class 객체 여부 확인

lam = set(dir(lambda x,y : x+y))
print(type(lambda x,y : x+y))

obj = set(dir(object))

for i in (lam-obj) :
    print(i)

a = lambda x,y : x+y

print(a)
print(a.__name__)
print(a.__qualname__)

a = lambda x=100,*,y=100 : x+y

print(a)
print(a.__annotations__)
print(a.__defaults__)
print(a.__kwdefaults__)

- 람다 함수 표현식 부분에 함수 호출 처리



def add(x,y) :
    return x+y

a = lambda x,y : add(x,y)

print(a(10,10))

### 3.2 즉시 실행 함수(Immediately - invoked function express)

- lambda 정의하고 즉시 실행 처리


lambda x : x (1)

(lambda x : x )(1)

- lambda 함수 재사용하기
    - lambda 함수는 한 번 쓰고 버리는 1회성으로 많이 사용함
    - 재사용하고자 할 경우
        - 이름없는 함수라서 네임스페이스에 할당되지 않으므로 다른 변수에 할당해서 재사용 할 수 있음
    - lambda 함수도 함수 클래스의 인스턴스이므로 객체의 인스턴스로 사용이 가능하며 객체 네임스페이스로 관리할 수도 있음


add = lambda x,y : x+y

print(add)
print(add.__name__)

print(add.__call__(5,5))
print(add(10,10))

add = lambda x,y : add.count

print(add)
add.count= 0

print(add.__dict__)
print(add(5,5))
add.count +=1
print(add.__dict__)


### 3.3 지능형 리스트(List Comprehension)에서 람다 함수 사용하기

- 지능형 리스트 내의 익명함수 처리
    - 리스트를 작성할 때 람다함수가 원소로 만들어지도록 구성함
    -


l = [ lambda  : x  for x in range(3)]

for i in l :
    print(i, i())


l = [ (lambda  : x)()  for x in range(3)]

print(l)

l = [ lambda  x=x : x  for x in range(3)]

for i in l :
    print(i, i())

l = [ lambda  x=n : x  for n in range(3)]

for i in l :
    print(i, i())

## **4. 내부 함수(Nested Function)**

- 내부 함수(Nested Function)
    - 함수 안에 정의해서 실행할 수 있는 함수 (일반적인 함수는 외부 함수(Outer Function))
    - 함수를 함수 내부에 정의해서 사용하므로 함수 간의 네임스페이스를 처리하는 스코프도 내부적으로 생성됨

### 4.1 내부 함수 정의하기

- 함수 내에 함수 정의 및 내부 실행처리
    - 외부 함수 내의 기능을 나누고 내부 함수로 정의해서 외부 함수의 보조 기능을 처리하는 방식


def math_func1(x,y,op) :

    def add_() :
        return x+y
    def sub_() :
        return x-y
    def mul_() :
        return x*y
    def div_() :
        return x/y

    op_func = {'+': add_, "-":sub_, "*":mul_, "/":div_}[op]

    return op_func()

print(math_func1(5,5,'+'))
print(math_func1(5,5,'-'))
print(math_func1(5,5,'*'))
print(math_func1(5,5,'/'))

- 내부 함수 호출을 반환에서 사용하기

def math_func1(x,op) :

    def add_(y) :
        return x+y
    def sub_(y) :
        return x-y
    def mul_(y) :
        return x*y
    def div_(y) :
        return x/y

    op_func = {'+': add_, "-":sub_, "*":mul_, "/":div_}[op]

    return op_func

add = math_func1(5,'+')
print(add(5))
sub = math_func1(5,'-')
print(sub(5))
mul = math_func1(5,'*')
print(mul(5))
div = math_func1(5,'/')
print(div(5))

### 4.2 내부 함수가 외부로 전달된 환경 이해하기

- 외부함수의 반환값으로 내부 함수에 대한 정보 확인


def outer(x) :
    def inner(y) :
        return x+y

    return inner

inner = outer(5)

print(inner)

print(inner.__name__)
print(inner(5))

- 타 모듈의 함수를 내부 함수에 지정



import operator as op

def outer_(op_code) :
    inner_ = {'+':op.add,
             '-':op.sub,
             '*':op.mul,
             '/':op.truediv}[op_code]
    return inner_

inner = outer_('/')
print(inner)
print(inner(5,5))

import operator as op

def outer_(op_code) :
    def inner_(x,y) :
        return  {'+':op.add,
             '-':op.sub,
             '*':op.mul,
             '/':op.truediv}[op_code](x,y)
    return inner_

inner = outer_('/')
print(inner)
print(inner(5,5))

- 내부 함수로 외부 함수의 매개변수 자료형 검증


def outer_check(type_code) :
    def type_check(a) :
        return isinstance(a,type_code)

    def inner_(x,y) :
        if not type_check(x) :
            x = type_code(x)
        if not type_check(y) :
            y = type_code(y)
        return x+y

    return inner_


inner = outer_check(int)
print(inner(1.1,2.2))

inner = outer_check(float)
print(inner(1.3,2))

### 4.3 내부 함수 안에서 nonlocal 변수 사용하기

- 함수별 Namespace 생성 확인하기


import pprint

def outer_local(x,y) :

    def inner_local(a,b) :
        return locals()
    print("outer_local")
    pprint.pprint(locals())
    return inner_local

inner = outer_local(10,20)
print("inner_local")
print(inner(30,40))

- 외부 함수 Namespace 사용하기


import pprint

def outer_local(x) :

    def inner_local(y) :
        x = x + 1
        return x

    return inner_local

inner = outer_local(10)
print("inner_local")
print(inner(40))

import pprint

def outer_local(x) :

    def inner_local(y) :
        nonlocal x
        x = x + 1
        return x

    return inner_local

inner = outer_local(10)
print("inner_local")
print(inner(40))

- 내부함수 내에 내부함수를 내포하기

def out_(x) :
    def inn_1(y) :
        def inn_2(z) :
            #nonlocal y
            y = y+1
            return x+y+z
        return inn_2
    return inn_1

inn_1 = out_(10)
inn_2 = inn_1(20)
print(inn_2(30))

def out_(x) :
    def inn_1(y) :
        def inn_2(z) :
            nonlocal y
            y = y+1
            return x+y+z
        return inn_2
    return inn_1

inn_1 = out_(10)
inn_2 = inn_1(20)
print(inn_2(30))

## **5. 파이썬 제공 내장 함수**

### 5.1 계산 및 문자 변환 내장 함수

- Sequence 자료형 합 구하기 : sum

print(sum([1,2,3,4]))
print(sum([1,2,3,4],5))

l = [(1,2),(7,9),(3,4)]

l.sort(key=sum)
print(l)

- 소수점 조정 및 몫과 나머지 구하기


print(type(round))
print(type(divmod))

f = 100.123456789
print(round(f))
print(round(f,3))
print(round(f,5))

d = 100
n = 23

print(divmod(d,n))

print(d // n)
print(d % n)

- 절대값, 제곱과 논리식 구하기


print(type(abs))

print(abs(-100))


import math

print(type(pow))

print(pow(10,2))
print(pow(10,2,3))
print(math.pow(10,3))
print(pow(10,1/2))
print(math.sqrt(10))

- 숫자를 문자로 문자를 숫자로 변환하기


s = "알아보고싶은파이썬"

l = list(map(ord,s))
print(l)

ls = "".join(list(map(chr,l)))
print(ls)

s = "IwanttoknowPython "

l = list(map(ord,s))
print(l)

ls = "".join(list(map(chr,l)))
print(ls)

- 논리식의 결과로 처리하기


print(type(any), type(all))

print(any([]))
print(any([None]))

print(all([]))
print(all([None]))

print(any({'a':None}))
print(any({}))
print(all({'a':None}))
print(all({}))

print(any(""))
print(all(""))

### 5.2 정렬 내장 함수 이해하기

- 정렬 함수 sorted


print(sorted)

l = ['abc', 'bc', 'a']

s = sorted(l)
print(s)

l = ['abc', 'bc', 'a']

s = sorted(l,reverse=True)
print(s)

l = ['abc', 'bc', 'a']

s = sorted(l,key=len)
print(s)

l = ['abc', 'bc', 'a']
l.sort()
print(l)

l = ['abc', 'bc', 'a']
l.sort(reverse=True)
print(l)

l = ['abc', 'bc', 'a']
l.sort(key=len)
print(l)

- 문자열을 바로 실행하기

s = "exec_a = '변수에 할당하기'"

exec(s)

print(globals()["exec_a"])

s = "a_e = a_e + 100"
a_e = 100

exec(s)

print(globals()["a_e"])

s = """
def add_exec(x,y) :
    return x+y

"""
exec(s)

print(globals()["add_exec"])
print(globals()["add_exec"](10,10))

print(add_exec(20,20))

%%writefile exec_add.py
s = """
def add_exec(x,y) :
    return x+y

"""
exec(s)

import exec_add

print(exec_add.add_exec(20,30))

- 컴파일에서 eval, exec 실행을 지정한 후에 나중에 실행하기

sc = """
class Person :
    def __init__(self,name) :
        self.name = name
    def getname(self) :
        return self.name
"""

ex = compile(sc,"fakefile",'exec')


eval(ex)

p = Person("정찬혁")

print(p.getname())

sv = "Person('박세본')"
ev = compile(sv,"fakefile",'eval')

b = eval(ev)
print(b.getname())

- 약수 구하기

def common_div(x) :
    s = set()
    for i in range(1,x+1) :
        if x % i == 0 :
            s.add(i)
    return s


a = int(input(" 수를 입력하세요"))

ass = common_div(a)
b = int(input(" 수를 입력하세요"))
bss = common_div(b)

print(ass)
print(bss)

print((ass & bss))

a = int(input(" 수를 입력하세요 "))
b = int(input(" 수를 입력하세요 "))

print(a,b)

def gcd(p, q) :
    print(p,q)
    if (q == 0) :
        return p;
    return gcd(q, p%q)

print(" 최대 공약수 ",gcd(a,b))

## **6. 함수 정보 조회**

### 6.1 Function 및 code class 이해하기

- 함수(람다함수 포함)는 로딩될 때 function 클래스에 속성이 만들어지고 이 내부에 code 클래스의 인스턴스까지 연결하여 속성을 확인할 수 있음


- 함수의 자료형 확인

def addd(x,y) :
    return x+y

print(type(addd))
print(isinstance(addd, type(addd)))

- 함수 내의 code 클래스 정보 확인하기

import pprint

print(type(addd.__code__))

co = set(dir(addd.__code__))
o = set(dir(object))
pprint.pprint(co-o)

print(addd.__code__.co_argcount)
print(addd.__code__.co_name)
print(addd.__code__.co_names)
print(addd.__code__.co_varnames)

- 함수 소스 및 바이트 코드 보기


import inspect

def addd(x:int,y:int) -> int :
    return x+y

print(inspect.getsource(addd))

import dis

print(dis.dis(addd))

### 6.2 함수 시그니처

- 함수 시그니처
    - 함수의 입력과 출력을 정의하는 부분
    - 함수의 이름, 매개변수의 개수, 매개변수의 자료형, 반환값 등을 포함

- 시그니처와 매개변수 정보 확인하기

import inspect

def addd(x:int,y:int) -> int :

    return x+y

a = inspect.signature(addd)
print(type(a))
print(a)

print(a.parameters)
print(a.parameters['x'])
print(a.parameters['y'])
print(a.return_annotation)

- 함수에 대한 기본 정보도 함수로 조회하기


import inspect

def addd(x:int,y:int) -> int :
    """ addd 함수에 대한 __doct__ """
    return x+y

a = inspect.getdoc(addd)
print(type(a))
print(a)

m = inspect.getmodule(addd)
print(m)

b = inspect.getargs(addd.__code__)
print(b)

c = inspect.getsourcefile(addd)
print(c)

